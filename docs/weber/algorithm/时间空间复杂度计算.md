# 算法之时间复杂度、空间复杂度计算

## 时间复杂度

通用方法：「大O符号表示法」(算法的渐进时间复杂度)，即 T(n) = O(f(n))，其中f(n)表示每行代码执行次数之和，O表示正比例关系,她表示的并不是算法的真实执行时间，而是代码执行时间的增长变化趋势

一个简单的例子：

```js
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

假定每行代码的执行时间一样，用1颗粒时间来进行表示，那么这个例子执行的时间就是 (1+2n) * 颗粒时间,即： T(n)=(1+2n) * 颗粒时间，也就是说这个算法的耗时是随n变化而变化的，因此简化一下就是
T(n)=O（n）

常见的事件复杂度量级有：

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

### 常数阶

无论代码执行多少行，只要没有循环登复杂结构，那么这个代码的时间复杂度就都是O(1)

### 线性阶

比如for循环，消耗事件随着n的变化而变化-> O(n)

### 对数阶O(logN)

```js
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

在这个循环中，每次i都乘以2，乘完之后，i距离n越来越近，也就是说2的x次方等于n，那么x=log2^n -> 时间复杂度为：O（logN)

### 线性对数阶

把对数阶循环n次，时间复杂度就是n*O(logN),也就是O(nlogN)

### 平方阶、立方阶...n层循环

## 空间复杂度

时间复杂度不是用来计算程序实际具体耗时，与之对应，空间复杂度也不是用来计算程序实际占用空间的

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

## O(1)

```js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
// 代码中的i、j所分配的空间不随着处理数据量的变化而变化 -> 空间复杂度 S(n) = O(1)
```

## O(n)

```js
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
// 第一行new了一个数组出来，这个数据占用大小为n，后续代码并没有再分配新的空间，因此这个复杂度为 S(n) = O(n)
```
